diff --git a/lib/CodeGen/AsmPrinter/AsmPrinter.cpp b/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
index 9bbc77b3056..cebb362d679 100644
--- a/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
+++ b/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
@@ -1539,6 +1539,30 @@ bool AsmPrinter::doFinalization(Module &M) {
         OutStreamer->EmitAddrsigSym(getSymbol(&GV));
   }
 
+  // RoboVM change: Emit spfpoffset symbols if requested to do so. The symbols are
+  // created in ARMFrameLowering::emitPrologue and AAarch64FrameLowering::emitPrologue.
+  if (MMI->getModule()->getNamedValue("robovm.emitSpFpOffsets")) {
+    bool InTextSeciton = false;
+    for (const Function &F : *(MMI->getModule())) {
+      if (F.isDeclaration())
+        continue;
+
+      MCSymbol *OffsetValue = OutContext.lookupSymbol(Twine("_") + F.getName() + ".spfpoffset.internal");
+      if (OffsetValue) {
+        if (!InTextSeciton) {
+          OutStreamer->SwitchSection(getObjFileLowering().getTextSection());
+          OutStreamer->EmitCodeAlignment(4);
+          InTextSeciton = true;
+        }
+        // dkimitsa: emit new symbol without values attached to bypass crashes on asserts (e.g. shall not be used and not to be variable)
+        MCSymbol *Offset = OutContext.getOrCreateSymbol(Twine("_") + F.getName() + ".spfpoffset");
+        OutStreamer->EmitLabel(Offset);
+        OutStreamer->EmitSymbolAttribute(Offset, MCSA_Global);
+        OutStreamer->EmitIntValue(((const MCConstantExpr *) OffsetValue->getVariableValue())->getValue(), 4);
+      }
+    }
+  }
+
   // Allow the target to emit any magic that it wants at the end of the file,
   // after everything else has gone out.
   EmitEndOfAsmFile(M);
diff --git a/lib/Target/AArch64/AArch64FrameLowering.cpp b/lib/Target/AArch64/AArch64FrameLowering.cpp
index 6dc5d19862a..73bd2f23b57 100644
--- a/lib/Target/AArch64/AArch64FrameLowering.cpp
+++ b/lib/Target/AArch64/AArch64FrameLowering.cpp
@@ -127,6 +127,7 @@
 #include "llvm/Support/raw_ostream.h"
 #include "llvm/Target/TargetMachine.h"
 #include "llvm/Target/TargetOptions.h"
+#include "llvm/MC/MCSymbol.h"
 #include <cassert>
 #include <cstdint>
 #include <iterator>
@@ -830,6 +831,14 @@ void AArch64FrameLowering::emitPrologue(MachineFunction &MF,
     // LR if those are saved).
     emitCalleeSavedFrameMoves(MBB, MBBI);
   }
+
+  // RoboVM change: Create a symbol which stores the sp<->fp offset and sp alignment. The symbol
+  // is finally emitted in AsmPrinter::doFinalization().
+  MCSymbol *Offset = MMI.getContext().getOrCreateSymbol(Twine("_") + MF.getName() + ".spfpoffset.internal");
+  // Calculare the SP<->FP offset for the function. We subtract 16 to ignore fp/lr on the stack.
+  // We divide by 4 since the offset is always at least a multiple of 4.
+  uint32_t spFpOffset = (MFI.getStackSize() - 16) >> 2;
+  Offset->setVariableValue(MCConstantExpr::create(spFpOffset, MMI.getContext()));
 }
 
 void AArch64FrameLowering::emitEpilogue(MachineFunction &MF,
diff --git a/lib/Target/ARM/ARMFrameLowering.cpp b/lib/Target/ARM/ARMFrameLowering.cpp
index 56ad7a0f044..de4fd0e0d3b 100644
--- a/lib/Target/ARM/ARMFrameLowering.cpp
+++ b/lib/Target/ARM/ARMFrameLowering.cpp
@@ -46,6 +46,7 @@
 #include "llvm/MC/MCDwarf.h"
 #include "llvm/MC/MCInstrDesc.h"
 #include "llvm/MC/MCRegisterInfo.h"
+#include "llvm/MC/MCSymbol.h"
 #include "llvm/Support/CodeGen.h"
 #include "llvm/Support/CommandLine.h"
 #include "llvm/Support/Compiler.h"
@@ -55,6 +56,7 @@
 #include "llvm/Support/raw_ostream.h"
 #include "llvm/Target/TargetMachine.h"
 #include "llvm/Target/TargetOptions.h"
+#include "llvm/IR/Module.h"
 #include <algorithm>
 #include <cassert>
 #include <cstddef>
@@ -760,6 +762,18 @@ void ARMFrameLowering::emitPrologue(MachineFunction &MF,
   // checks for hasVarSizedObjects.
   if (MFI.hasVarSizedObjects())
     AFI->setShouldRestoreSPFromFP(true);
+
+  // RoboVM change: Create a symbol which stores the sp<->fp offset and sp alignment. The symbol
+  // is finally emitted in AsmPrinter::doFinalization().
+  MCSymbol *Offset = Context.getOrCreateSymbol(Twine("_") + MF.getName() + ".spfpoffset.internal");
+  // Calculare the SP<->FP offset for the function. We subtract 8 to ignore r7/lr on the stack.
+  // We divide by 4 since the offset is always at least a multiple of 4.
+  uint32_t spFpOffset = (GPRCS1Size - 8 + GPRCS2Size + DPRGapSize + DPRCSSize + NumBytes + AFI->getNumAlignedDPRCS2Regs()*8) >> 2;
+  // Calculate the stack alignment. It's at least a multiple of 4 so we divide by 4.
+  // We subtract by 1 since alignment/4 is always at least 1.
+  uint32_t spAlignment = (MFI.getMaxAlignment() >> 2) - 1;
+  // We store the stack alignment in the 4 MSBs of the symbol value.
+  Offset->setVariableValue(MCConstantExpr::create(spFpOffset | (spAlignment << 28), Context));
 }
 
 void ARMFrameLowering::emitEpilogue(MachineFunction &MF,
